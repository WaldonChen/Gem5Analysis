% Gem5 代码解析
% Waldon Chen (waldonchen@gmail.com)
% October 30, 2013

Gem5 代码解析
===============

一些声明
----------

### 关于代码

文中会引用大量Gem5代码，我会给出它在代码树中的位置。
由于Gem5中采用了SWIG，一些python文件只能在build后才会生成。
所以，代码路径使用build后的代码树，即build/&lt;arch&gt;/目录下的代码。
文中&lt;arch&gt;指的是X86，虽然我仍以&lt;arch&gt;标识。


Gem5模拟器的启动
-----------------------

Gem5模拟器的控制里采用python代码来完成的。
所以，我将先从python代码中找出一条通往底层C++代码的通路。

### Python通路

为了尽量简单，我将从SE模式入手。

在文件_configs/examples/se.py_中, se.py配置好各种选项，包括

* CPU
* Cache
* Memory
* Memory Bus

最后，调用Simulation.run()运行模拟器。

___configs/examples/se.py___
```python
system = System(cpu = [CPUClass(cpu_id=i) for i in xrange(np)],
                physmem = SimpleMemory(range=AddrRange("512MB")),
                membus = CoherentBus(), mem_mode = test_mem_mode)
...
root = Root(full_system = False, system = system)
Simulation.run(options, root, system, FutureClass)
```

接下来看看Simulation.run()的细节, 目录树也从 __configs/__ 进入 __build/&lt;arch&gt;/__ 。

___build/&lt;arch&gt;/python/m5/simulate.py___
```python
def simulate(*args, **kargs)
	...
	return internal.event.simulate(*args, **kwargs)
```
![](./images/arrow_down_48.png 'next_code')

___build/&lt;arch&gt;/python/swig/event.py___ (generated by SWIG)
```python
def simulate(*args)
	return _event.simulate(*args)
simulate = _event.simulate
```
![](./images/arrow_down_48.png 'next_code')

___build/&lt;arch&gt;/sim/simulate.cc___
```c
SimLoopExitEvent *
simulate(Tick num_cycles)
{
	// ...

	while(1) {
		// ...
		Event *exit_event = mainEventQueue.serviceOne();
		// ...
	}
}
```

### 事件驱动

___build/&lt;arch&gt;/sim/simulate.cc___
```c
SimLoopExitEvent *
simulate(Tick num_cycles)
{
	// ...
	Event *limit_event =
		new SimLoopExitEvent("simulate() limit reached", 0);
	mainEventQueue.schedule(limit_event, num_cycles);

	while(1) {
		// there should always be at least one event (the SimLoopExitEvent
		// we just scheduled) in the queue
		assert(!mainEventQueue.empty());
		// ...
		Event *exit_event = mainEventQueue.serviceOne();
		if (exit_event != NULL) {
			// ...
			SimLoopExitEvent *se_event;
			se_event = dynamic_cast<SimLoopExitEvent *>(exit_event);

			// ...
			// if we didn't hit limit_event, delete it
			if (se_event != limit_event) {
				assert(limit_event->scheduled());
				limit_event->squash();
			}

			return se_event;
		}

		if (async_event) {
			// ...
		}
	}
}
```

CPU Model
-----------

### Atomic Simple CPU


### Timing Simple CPU


### Inorder Detail CPU


### Out-of-Order Detail CPU


Memory Model
---------------

### Classic Memory Model


### Ruby Memory Model

